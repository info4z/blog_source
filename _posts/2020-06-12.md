---
title: Fork/Join
date: 2020-06-12
categories:
- 高性能编程
tags: 
- 多线程并发编程
- J.U.C并发编程包
---



# 一 : 

## (五) Fork/Join并发处理框架

### 1: 用来做什么

- ForkJoinPool 是 ExecutorService 接口的实现, 它专为可以递归分解成小块的工作而设计; fork/join 框架将任务分配给线程池中的工作线程, 充分利用多处理器的优势, 提高程序性能

- 使用 fork/join 框架的第一步是编写执行一部分工作的代码; 类似的伪代码如下

  ```
  如果(当前工作部分足够小)
  	直接做这项工作
  其他
  	把当前工作分成两部分
  	调用这两个部分并等待结果
  ```

- 将此代码包装在 ForkJoinTask 子类中, 通常是 RecursiveTask (可以返回结果) 或 RecursiveAction

### 2: 意图梳理

- 关键点:
  - fork : 将任务分解成多个新任务
  - join : 汇集任务执行结果

### 3: 经典网关场景, 查询多个系统数据

- 移动互联网的情况
  - 一个接口请求要获取很多信息
  - 后端分布式系统, 拆分成多个子系统
- 后端接口执行(大概流程)
  1. 收到一个请求
  2. 调用多个服务接口获取其他系统的数据
  3. 最后汇总返回
- 注意 : 代码逻辑涉及到串行的过程, 运行时间会发生累计, 随着需要调用的接口的数量的增多, 响应时间会越来越长, 针对于**响应时间限制**, 通常开发公司会有明确规定, 例如 : 内部调用的核心接口的响应时间通常为10ms, 对外可以扩展到50ms

### 4: 实现思路

- 每个 Worker 线程都维护一个任务队列, 即 ForkJoinWorkerThread 中的任务队列
- 任务队列是双向队列, 这样可以同时实现 LIFO 和 FIFO
- 子任务会被加入到原先任务所在 worker 线程的任务队列(workQueue); worker 线程用 LIFO 的方法取出任务, 后进队列的任务先取出来(子任务总是后加入队列, 但是需要先执行); 当任务队列为空, 会随机从其他的 worker 的队列中拿走一个任务执行(工作窃取: steal work);
- 如果一个 worker 线程遇到了 join 操作, 而这时候, 正在处理其他任务, 会等到这个任务结束; 否则直接返回
- 如果一个 worker 线程窃取任务失败, 它会用 yield 或者 sleep 之类的方法休息一会儿, 再尝试(如果所有线程都是空闲状态, 即没有任务运行, 那么该线程也会进入阻塞状态等待新任务的到来)

### 5: 适用

- **使用尽可能少的线程池** : 再大多数情况下, 最好的决定是为每个应用程序或系统使用一个线程
- 如果不需要特定调整, 请使用默认的公共线程池
- 使用合理的阈值将 ForkJoinTask 拆分为子任务
- 避免在 ForkJoinTask 中出现任何阻塞
- **适用场景** : 数据处理, 结果汇总, 统计等; java8实例: java.util.Arrays 类用于其 parallelSort() 方法; 其目的是进行内存运算方面的操作, 因此**不适合**用于网络接口调用, 数据库查询, 文件操作等; 所以如果需要使用, 只定义一个 ForkJoinPool 就好, 线程数量尽量和 CPU 核数差不多, 主要进行非阻塞的代码处理

### 6: 结语

- 总结 :
  1. 本质上是一个线程池, 如果需要使用, 只需要定义一个 ForkJoinPool 即可
  2. 线程数量尽量和 CPU 核心数差不多; 例如 8 核 CPU 就设置 8 个线程
  3. 适用于非阻塞(non blocking)的代码处理; 例如网络接口调用, 数据库查询, 文件操作等操作**并不适用**
- 工作窃取带来的性能提升偏理论, API 的复杂性高, 实际研发中可控性来说不如其他 API, **非内存操作并不适用**