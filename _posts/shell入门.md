---
title: shell入门
excerpt: Linux三剑客, grep主打查找功能, sed主要是编辑, awk主要是分割处理
date: 2023-01-27
categories: 服务器
tags:  shell
---





## 一 : Shell 概述 

### (一) 什么是 Shell

Shell 是一个用 C 语言编写的程序, 它是用户使用 Linux 的桥梁。Shell 既是一种命令语言, 又是一种程序设计语言。

Shell 是指一种应用程序, 这个应用程序提供了一个界面, 用户通过这个界面访问操作系统内核的服务。

硬件 => 内核 => shell命令解释器 => 外层应用程序

Ken Thompson 的 sh 是第一种 Unix Shell, Windows Explorer 是一个典型的图形界面 Shell。

### (二) Shell 脚本

Shell 脚本(shell script), 是一种为 shell 编写的脚本程序。

业界所说的 shell 通常都是指 shell 脚本, 但读者朋友要知道, shell 和 shell script 是两个不同的概念。

由于习惯的原因, 简洁起见, 本文出现的 "shell编程" 都是指 shell 脚本编程, 不是指开发 shell 自身。

shell命令解释器 : 把命令翻译成机器语言, 再把结果翻译成命令

### (三) shell 的分类

| Shell 类别              | 易学性 | 可移植性 | 编辑性 | 快捷性 |
| ----------------------- | ------ | -------- | ------ | ------ |
| Bourne Shell (sh)       | 容易   | 好       | 较差   | 较差   |
| Korn Shell (ksh)        | 较难   | 较好     | 好     | 较好   |
| **Bourne Again (Bash)** | **难** | **较好** | **好** | **好** |
| POSIX Shell (psh)       | 较难   | 好       | 好     | 较好   |
| C Shell (csh)           | 较难   | 差       | 较好   | 较好   |
| TC Shell (tcsh)         | 难     | 差       | 好     | 好     |

Shell 的两种主要语法类型有 Bourne 和 C, 这两种语法彼此不兼容。

- Bourne 家族主要包括 sh、ksh、Bash、psh、zsh；
- C 家族主要包括:csh、tcsh (Bash 和 zsh 在不同程度上支持 csh 的语法)。

我们可以通过 `/etc/shells` 文件来查询 Linux 支持的 Shell。命令如下 :

```shell
[root@localhost ~]# vi /etc/shells

/bin/sh
/bin/Bash
/sbin/nologin
/bin/tcsh
/bin/csh
```



## 二 : 特殊符号

| 符 号 | 作 用                                                        |
| ----- | ------------------------------------------------------------ |
| ''    | 单引号。在单引号中所有的特殊符号, 如"$"和"`"(反引号)都没有特殊含义。 |
| ""    | 双引号。在双引号中特殊符号都没有特殊含义, 但是"$"、"`"和"\\"是例外, 拥有"调用变量的值"、"引用命令"和"转义符"的特殊含义。 |
| ``    | 反引号。反引号括起来的内容是系统命令, 在 Bash 中会先执行它。和$()作用一样, **不过推荐使用$()**, 因为反引号非常容易看错。 |
| $     | 用于调用变量的值, 如需要调用变量 name 的值时, 需要用 `$name` 的方式得到变量的值。 |
| ${}   | 括号里面写变量, 相当于 `$name`                               |
| $()   | 和反引号作用一样, 用来引用系统命令。例如: `$(df -h)`         |
| $[]   | 括号里面运算式, 也可以用 `$((...))`, 例如: `$[1+2]`          |
| $(()) | 括号里面写运算式, 和 `$[]` 作用一样, 例如: `$((1+2))`        |
| ()    | 用于一串命令执行时, ()中的命令会在子 Shell 中运行            |
| {}    | 用于一串命令执行时, {}中的命令会在当前 Shell 中执行。也可以用于变量变形与替换。 |
| []    | 用于变量的测试。                                             |
| #     | 在 Shell 脚本中, #开头的行代表注释。                         |
| \     | 转义符, 跟在 \ 之后的特殊符号将失去特殊含义, 变为普通字符。如 `\$` 将输出"$"符号, 而不当做是变量引用。 |



## 三 : 变量

### (一) 用户自定义变量

这种变量是最常见的变量, 由用户自由定义变量名和变量的值。

注意变量定义的时候 : 变量名不能以数字开头, `=`两边不要写空格, 变量值必须是连续的字符串

```shell
#变量名不能用数字开头
[root@localhost ~]# 2name="Bob Han"
-bash: 2name=Bob: command not found

#等号左右两侧不能有空格
[root@localhost ~]# name = "Bob Han"
-bash: name: command not found

#变量的值如果有空格, 必须用引号包含
[root@localhost ~]# name=Bob Han
-bash: Han: command not found
```

变量调用就直接使用 `$变量名` 即可

```shell
#输出变量 name 的值
[root@localhost ~]# echo $name
Bob
```

变量查看 : 直接使用 `set` 命令, 会查询系统中所有的变量, 包含用户自定义变量和环境变量

```shell
[root@localhost ~]# set [选项]
选项:
-u: 如果设定此选项, 调用未声明变量时会报错(默认无任何提示)
-x: 如果设定此选项, 在命令执行之前, 会把命令先输出一次
```

删除变量 : `unset`

```shell
# 注意: 直接写变量名,不加$符号
[root@localhost ~]# unset name	
```

### (二) 环境变量

这种变量中主要保存的是和系统操作环境相关的数据, 比如当前登录用户, 用户的家目录, 命令的提示符等

- 环境变量的变量名可以自由定义, 但是一般对系统起作用的环境变量的变量名是系统预先设定好的
- 系统自带的环境变量 : **命令是确定的, 作用是确定的, 但内容可以自定义**
- 用户自定义的环境变量 : **命令, 作用和内容都可以自定义**
- **环境变量名建议大写, 便于区分**

环境变量设置

```shell
# 使用 export 声明的变量即是环境变量
[root@localhost ~]# export age="18"
```

环境变量查询和删除

```shell
# 查询环境变量gender,env 命令只能查看环境变量,而set命令可以查看所有变量
[root@localhost ~]# env | grep gender
# 删除环境变量gender
[root@localhost ~]# unset gender
```

系统默认环境变量 `PATH` : 系统查找命令的路径

```shell
# PATH变量的值是用":"分割的路径,这些路径就是系统查找命令的路径
[root@localhost ~]# echo $PATH
/usr/lib/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
```

* 也就是说, 如果将test.sh放到 `/root/bin` (其中一个目录)下, 程序也可以直接执行; 或者定义 `PATH=$PATH:/root/sh` 将脚本所在目录追加进去

系统默认环境变量 `PS1` : 命令提示符设置

```shell
# 默认的提示符是显示"[用户名@简写主机名 最后所在目录]提示符"
[root@localhost ~]# echo $PS1
[\u@\h \W]\$
```

* 如果需要永久修改, 可以写入配置文件 `/etc/bashrc`

系统默认环境变量 `LANG` : 语系变量

```shell
[root@localhost src]# echo $LANG
zh_CN.UTF-8

# 查询支持的语系
[root@localhost src]# locale -a | more

# 查询当前系统的语系(当前系统使用的语系)
[root@localhost src]# locale
LANG=zh_CN.UTF-8
LC_CTYPE="zh_CN.UTF-8"
LC_NUMERIC="zh_CN.UTF-8"
LC_TIME="zh_CN.UTF-8"
LC_COLLATE="zh_CN.UTF-8"
LC_MONETARY="zh_CN.UTF-8"
LC_MESSAGES="zh_CN.UTF-8"
LC_PAPER="zh_CN.UTF-8"
LC_NAME="zh_CN.UTF-8"
LC_ADDRESS="zh_CN.UTF-8"
LC_TELEPHONE="zh_CN.UTF-8"
LC_MEASUREMENT="zh_CN.UTF-8"
LC_IDENTIFICATION="zh_CN.UTF-8"
LC_ALL=

# 查询系统的默认语系(下次重启之后系统所使用的语系)
[root@localhost src]# cat /etc/sysconfig/i18n 
LANG="zh_CN.UTF-8"
```

### (三) 位置参数变量

这种变量主要是用来向脚本当中传递参数或数据的, 变量名不能自定义, 变量作用是固定的; **只有内容可以自定义**

| 位置参数变量 | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| `$n`         | n 为数字, $0 代表命令本身, $1-$9 代表第一到第九个参数, **十以上的参数需要用大括号包含, 如${10}** |
| `$*`         | 这个变量代表命令行中所有的参数, **`$*`把所有的参数看成一个整体** |
| `$@`         | 这个变量也代表命令行中所有的参数, 不过**`$@`把每个参数区分对待** |
| `$#`         | 这个变量代表命令行中所有参数的个数                           |

### (四) 预定义变量

是 Bash 中已经定义好的变量, 变量名不能自定义, 变量作用也是固定的; **只有内容可以自定义**

| 预定义变量 | 作 用                                                        |
| ---------- | ------------------------------------------------------------ |
| $?         | 最后一次执行的命令的返回状态。<br />如果这个变量的值为 0, 证明上一个命令正确执行；<br />如果这个变量的值为非 0(具体是哪个数, 由命令<br/>自己来决定), 则证明上一个命令执行不正确了 |
| $$         | 当前进程的进程号(PID)                                        |
| $!         | 后台运行的最后一个进程的进程号(PID)                          |



## 四 : 通配符和正则表达式

### (一) 通配符

| 通配符 | 作 用                                               | 示例                                                       |
| ------ | --------------------------------------------------- | ---------------------------------------------------------- |
| ?      | 匹配一个任意字符                                    |                                                            |
| *      | 匹配 0 个或任意多个任意字符, 也就是可以匹配任何内容 |                                                            |
| []     | 匹配中括号中任意一个字符                            | `[abc]` 代表一定匹配一个字符, 或者是 a, 或者是 b, 或者是 c |
| [-]    | 匹配中括号中任意一个字符, `-`代表一个范围           | `[a-z]`代表匹配一个小写字母。                              |
| [^]    | 逻辑非, 表示匹配不是中括号内的一个字符              | `[^0-9]`代表匹配一个不是数字的字符                         |

### (二) 正则表达式(regex)

| 元字符    | 作用                                               | 示例                                                         |
| --------- | -------------------------------------------------- | ------------------------------------------------------------ |
| `*`       | 前一个字符匹配 **0 次或任意多次**                  | `aa*` 查询a出现1次及以上                                     |
| `.`       | 匹配除了换行符外**任意一个**字符                   | `s..d` 会匹配在s和d这两个字母之间一定有两个字符的单词        |
| `^`       | 匹配**行首**                                       | `^hello` 会匹配以 hello 开头的行                             |
| $         | 匹配**行尾**                                       | `hello$` 会匹配以 hello 结尾的行                             |
| `[]`      | 匹配中括号中指定的**任意一个**字符, 只匹配一个字符 | `[aeiou]` 匹配任意一个元音字母, `[0-9]` 匹配任意一位数字, `[a-z][0-9]`匹配小写字和一位数字构成的两位字符 |
| `[^]`     | 匹配除中括号的字符以外的任意一个字符。             | `[^0-9]` 匹配任意一位非数字字符, `[^a-z]`表示任意一位非小写字母 |
| `\`       | 转义符。用于取消特殊符号的含义                     | `\.$` 查找以字符 `.` 结尾的行                                |
| `\{n\}`   | 表示其前面的字符恰好出现 n 次                      | `[0-9]\{4\}` 匹配 4 位数字, `[1][3-8][0-9]\{9\}` 匹配手机号码 |
| `\{n,\}`  | 表示其前面的字符出现不小于 n 次                    | `[0-9]\{2,\}` 表示两位及以上的数字                           |
| `\{n,m\}` | 表示其前面的字符至少出现n次, 最多出现m次           | `[a-z]\{6,8\}` 匹配 6~8 位的小写字母                         |

### (三) 总结

通常 : 正则表达式和通配符使用的场景是不同的

| 名称       | 作用                                     |
| ---------- | ---------------------------------------- |
| 正则表达式 | 用来在**文件内容**中匹配符合条件的字符串 |
| 通配符     | 用来匹配符合条件的**文件名**             |

其实这种区别只在 Shell 当中适用, 因为用来在文件当中搜索字符串的命令, 如 `grep`, `awk`, `sed` 等命令可以**支持正则**表达式; 而在系统当中搜索文件的命令, 如 `ls`, `find`, `cp` 这些命令**不支持正则**表达式, 所以只能使用 shell 自己的通配符来进行匹配了



## 五 : 常用指令

`grep`, `awk`, `sed` 也被称为Linux三剑客, **grep主打查找功能**，**sed主要是编辑**，**awk主要是分割处理**; 基础中的基础, 重点中的重点

### (一) 行提取 grep

命令格式

```shell
[root@localhost ~]# grep [选项] "搜索内容" 文件名
选项:
    -A 数字: 列出符合条件的行,并列出后续的n行 
    -B 数字: 列出符合条件的行,并列出前面的n行 
    -c: 统计找到的符合条件的字符串的次数
    -i: 忽略大小写
    -n: 输出行号
    -v: 反向查找
    --color=auto 搜索出的关键字用颜色显示
```

代码示例

```shell
# 查找用户信息文件/etc/passwd 中, 有多少可以登录的用户
[root@localhost ~]# grep "/bin/bash" /etc/passwd

# 查找包含有"root"的行, 并列出后续的3行
[root@localhost ~]# grep -A 3 "root" /etc/passwd

# 查找可以登录的用户, 并显示行号
[root@localhost ~]# grep -n "/bin/bash" /etc/passwd

# 查找不含有"/bin/bash"的行, 其实就是列出所有的伪用户
[root@localhost ~]# grep -v "/bin/bash" /etc/passwd 
```

### (二) 文本截取 awk

`awk` 是一个强大的文本分析工具, 相对于 `grep` 的查找, `sed` 的编辑, `awk` 在其**对数据分析并生成报告**时, 显得尤为强大。

简单来说`awk` 就是把文件**逐行的读入**, **以空格**为默认分隔符**将每行切片**, 切开的部分再进行各种分析处理。

```shell
[root@localhost ~]# awk '条件1{动作1} 条件2{动作2}…' 文件名
条件(Pattern) : 
    x > 10 	: 判断变量 x 是否大于 10
    x == y 	: 判断变量 x 是否等于变量 y
    A ~ B 	: 判断字符串 A 中是否包含能匹配 B 表达式的子字符串
    A !~ B 	: 判断字符串 A 中是否不包含能匹配 B 表达式的子字符串
动作(Action) : 
    格式化输出
    流程控制语句
```

awk 提供了一些内置变量

| awk 内置变量 | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| **$0**       | 代表目前 awk 所读入的整行数据。我们已知 awk 是一行一行读入数据的, $0 就代表当前读入行的整行数据 |
| **$n**       | 代表目前读入行的第 n 个字段                                  |
| **NF**       | 当前行拥有的字段(列)总数                                     |
| **NR**       | 当前 awk 所处理的行, 是总数据的第几行                        |
| **FS**       | 用户定义分隔符。awk 的默认分隔符是任何空格, 如果想要使用其他分隔符(如" : "), 就需要 `FS` 变量定义 |
| ARGC         | 命令行参数个数                                               |
| ARGV         | 命令行参数数组                                               |
| FNR          | 当前文件中的当前记录数(对输入文件起始为 1)                   |
| OFMT         | 数值的输出格式(默认为%.6g)                                   |
| OFS          | 输出字段的分隔符(默认为空格)                                 |
| ORS          | 输出记录分隔符(默认为换行符)                                 |
| RS           | 输入记录分隔符(默认为换行符)                                 |

简单代码示例

```shell
# 输出第1列和第3列
[root@localhost ~]# df -h | awk '{print $1 "\t" $3}'

# 查询可以登录的用户的用户名和 UID
[root@localhost ~]# awk 'BEGIN{FS=":"} {print $1 "\t" $3 }' /etc/passwd
```

awk 还提供了保留字, 保留字可以看作是<u>条件的一种</u>, 必须大写

| 保留字  | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| `BEGIN` | 在 awk 程序一开始时,尚未读取任何数据之前执行; BEGIN 后的动作只在程序开始时执行一次 |
| `END`   | 在 awk 程序处理完所有数据,即将结束时执行; END 后的动作只在程序结束时执行一次 |

保留字代码示例

```shell
# BEGIN和END都只会执行一次
[root@localhost ~]# df -h | grep -v Used | awk 'BEGIN{print "开始"} {print $1 ":" $3} END{print "完毕"}' 

# awk命令只要检测不到完整的单引号不会执行,所以这个命令的换行不用加入"\",就是一行命令
[root@localhost ~]# df -h | grep -v Used | awk 'BEGIN{print "统计开始:"} 
> {print "系统分区" $1 "已使用:" $3} END{print "统计完毕"}'
```

awk 的条件 : 关系运算符

| 条件 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| >    | 大于                                                         |
| <    | 小于                                                         |
| >=   | 大于等于                                                     |
| <=   | 小于等于                                                     |
| ==   | 等于。用于判断两个值是否相等,如果是给变量赋值,请使用`=`号    |
| !=   | 不等于                                                       |
| A~B  | 判断字符串 A 中是否包含能匹配 B 表达式的子字符串, 比字符串要加 `//`, 例如 : `$2 ~ /shell/` |
| A!~B | 判断字符串 A 中是否不包含能匹配 B 表达式的子字符串           |

条件示例代码

```shell
# 输出使用大于0的分区及使用情况
[root@localhost ~]# df -h | grep -v Used | awk '$3>0{print "系统分区" $1 "已使用:" $3}'

# 输出vda的使用情况
[root@localhost ~]# df -h | grep -v Used | awk '$1 ~ /vda/ {print "系统分区" $1 "已使用:" $3}'

# 如果在//中可以写入字符,也可以支持正则表达式,查询包含有vda的行,并打印第一字段和第五字段
[root@localhost ~]# df -h | awk '/vda[0-9]/ {printf $1 "\t" $5 "\n"} '
```

awk 流程控制

```shell
# 统计 PHP 成绩的总分 
[root@localhost ~]# awk 'NR==2{php1=$3} 
NR==3{php2=$3} 
NR==4{php3=$3;totle=php1+php2+php3;print "totle php is " totle}' awk_test.txt
```

`awk` 编程也允许在编程时使用函数(不常用)

```shell
# 定义函数test,包含两个参数,函数体的内容是输出这两个参数的值
[root@localhost ~]# awk 'function test(a,b) { printf a "\t" b "\n" } 
#调用函数 test,并向两个参数传递值
{ test($2,$6) } ' student.txt
```

awk 调用脚本`(-f)`

```shell
# 编写脚本
[root@localhost ~]# vi pass.awk
BEGIN {FS=":"}
{ print $1 "\t" $3}
# 调用脚本 -f
[root@localhost ~]# awk -f pass.awk /etc/passwd
```

**在 `awk` 编程中,因为命令语句非常长, 在输入格式时需要注意以下内容 :** 

- 多个 `条件{动作}` 可以用空格分割, 也可以用回车分割
- 在一个动作中, 如果需要执行多个命令, 需要用 `;` 分割, 或用回车分割
- 在 `awk` 中, 变量的赋值与调用都不需要加入 `$` 符
- 条件中判断两个值是否相同, 请使用`==`, 以便和变量赋值进行区分

### (三) 文本操作 sed

`sed` 主要是用来将数据进行**选取**, **替换**, **删除**, **新增**的命令

```shell
[root@localhost ~]# sed [OPTION]... {script-only-if-no-other-script} [input-file]...
选项 : 
    -n : 把经过sed处理的结果输出到屏幕(只查看sed命令操作的数据,如果不加则把所有数据都输出到屏幕)。
    -e : 允许对输入数据应用多条sed命令编辑,中间用";"隔开。
    -r :  在 sed 中支持扩展正则表达式。
    -i :  用 sed 的修改结果直接修改读取数据的文件,而不是由屏幕输出
    -f 脚本文件名 : 从 sed 脚本中读入 sed 操作。和 awk 命令的 -f 非常类似。
动作 : 
    a \ : 追加(append),在当前行后添加一行或多行; 添加多行时,除最后一行外,每行末尾需要用"\"代表数据未完结。
    c \ : 行替换(replace),用 c 后面的字符串替换原数据行; 替换多行时,除最后一行外,每行末尾需用"\"代表数据未完结
    i \ : 插入(insert),在当期行前插入一行或多行; 插入多行时,除最后一行外每行末尾需要用"\"代表数据未完结
    d :  删除(delete),删除指定的行
    p :  打印(print),输出指定的行
    s :  字串替换,用一个字符串替换另外一个字符串;格式为"行范围s/旧字串/新字串/"(和vim中的替换格式类似)
```

- **注意 :** `sed` 所做的修改并**不会直接改变文件的内容**(如果是用管道符接收的命令的输出,这种情况连文件都没有), 而是把修改结果只显示到屏幕上, **除非使用 `-i` 选项才会直接修改文件**。

代码示例

```shell
# 打印第二行
[root@localhost ~]# sed -n '2p' /etc/passwd

# 删除第二行到第四行的数据,但是文件本身并不会发生改变
[root@localhost ~]# sed '2,4d' /etc/passwd

# 在第二行后加入hello
[root@localhost ~]# sed '2a hello' /etc/passwd
# 如果需要多插几行,则需要用\换行
[root@localhost ~]# sed '2a hello \
> world' /etc/passwd

# 在第二行前插入hello,如果需要插入多行也需要\
[root@localhost ~]# sed '2i hello' /etc/passwd

# 将第二行数据替换掉
[root@localhost ~]# sed '2c hello world' /etc/passwd 

# 将第二行的bin替换成hello
[root@localhost ~]# sed '2s/bin/hello/' /etc/passwd
# 将第二行注释掉
[root@localhost ~]# sed '2s/^/#/' /etc/passwd
# 将第二行和第四行注释掉,用;隔开
[root@localhost ~]# sed '2s/bin/hello/;3s/daemon/world/' /etc/passwd
```

### (四) 列提取 cut

cut 命令的默认分隔符是制表符, 也就是 `tab` 键, **不支持空格**

```shell
[root@localhost ~]# cut OPTION... [FILE]...
选项 : 
-f column_number 	: 提取第几列
-d separate 		: 按照指定分隔符分割列(默认分隔符是制表符)
-c number 			: 不依赖分隔符来区分列,而是通过字符范围(行首为0)来进行字段提取(了解)
						"n-"表示从第n个字符到行尾; 
						"n-m"从第n个字符到第m个字符; 
						"-m"表示从第1个字符到第m个字符。
```

代码示例

```shell
# 提取第二列内容
[root@localhost ~]# cut -f 2 test.txt
# 那如果想要提取多列呢? 只要列号直接用","分开
[root@localhost ~]# cut -f 2,3 cut_test.txt 
# 查询普通用户的用户名和用户ID
[yuelu@localhost ~]$ grep "/bin/bash" /etc/passwd | grep -v "root" | cut -d ":" -f 1,3
# 按照字符进行提取,c表示character,后面跟表达式,8-代表的是提取所有行的第8个字符开始到行尾(10-20代表提取所有行的第10个字符到第20个字符,-8代表提取所有行从行首到第8个字符) 
[root@localhost ~]# cut -c 8- cut_test.txt 
```

### (五) 排序命令 sort

```shell
[root@localhost ~]# sort [选项] 文件名
选项 : 
-f :  忽略大小写
-b :  忽略每行前面的空白部分
-n :  以数值型进行排序,默认使用字符串型排序
-r :  反向排序
-u :  删除重复行。就是 uniq 命令
-t :  指定分隔符,默认是分隔符是制表符
-k n[,m] :  按照指定的字段范围排序。从第n字段开始,m字段结束(默认到行尾)
```

代码示例

```shell
# 排序用户信息文件,默认是用每行开头第一个字符来进行排序
[root@localhost ~]# sort /etc/passwd
# 反向排序-r
[root@localhost ~]# sort -r /etc/passwd
# 指定分隔符是":",排序范围是第三个(用第三字段开头,第三字段结尾排序)
[root@localhost ~]# sort -t ":" -k 3,3 /etc/passwd
```

### (六) 去重命令 uniq

`uniq` 命令是用来取消重复行的命令, 其实和 `sort -u` 选项是一样的

```shell
[root@localhost ~]# uniq [选项] 文件名
选项 : 
	-i :  忽略大小写
```

### (七) 统计命令 wc

```shell
[root@localhost ~]# wc [选项] 文件名
选项 : 
    -l : 只统计行数(print the newline counts)
    -w : 只统计单词数(print the word counts)
    -m : 只统计字符数(print the character counts)
    -c : print the byte counts
```


