---
title: 线程安全之可见性问题
date: 2020-03-13
categories:
- 高性能编程
tags: 
- 多线程并发编程
- 线程安全
---





> 使用多线程技术总是避免不了要操作同一个变量, 这个时候会不会有什么看不见的情况出现呢 ?



## 一 : 指令重排序(jit)

Java 编程语言的语义允许编译器和微处理器执行优化，这些优化可以与不正确的同步代码交互，从而产生看似矛盾的行为。

* 重排序

  ![](https://gcore.jsdelivr.net/gh/info4z/blog_images@main/images/image-20230115182732294.png) 

* 等效交换

  ![](https://gcore.jsdelivr.net/gh/info4z/blog_images@main/images/image-20230115182821426.png) 

通常 javac 将程序源码编译, 转换成 java 字节码(.class), jvm 通过解释字节码将其翻译成相应的机器指令, 逐条读入, 逐条解释翻译; 经过解释运行, 其运行速度必定会比可运行的二进制字节码程序慢; 为了提高运行速度, 引入了 **jit** 技术

当 **jit** 编译启用时(默认是启用的), jvm 读入 **.class 文件**解释后, 将其发给 jit 编译器; jit 编译器将字节码编译成本机机器代码(汇编指令), 在执行时 jit 会把翻译过的机器码保存起来, 已备下次使用; 因此从理论上来说, 采用该 jit 技术能够接近曾经纯编译技术

而 java 的指令重排序优化是在 jit 编译阶段, 因此 class 文件是看不出来的, 所以 javap 命令无法帮到你; 如果想要继续向下探索, 可以查看 jit 编译后的汇编代码

```shell
# 通过设置 jvm 的参数, 可以打印出 jit 编译的内容(非class文件)
server -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=jit.log
# 关闭jit优化
-Djava.compiler=NONE
```

这些优化可以与不正确的同步代码交互, 从而产生看似矛盾的行为; 这些优化是以单线程为角度的, 当发生多线程运行的时候可能会出现不确定的错误

## 二 : Shared Variables

Shared Variables : 共享变量

可以在线程之间共享的内存称为**共享内存**或**堆内存**; 所有实例字段, 静态字段和数组元素都存储在堆内存中

如果至少有一个访问是写的, 那么对同一个变量的两次访问(读或写)是冲突的

